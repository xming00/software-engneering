# Algorithm(演算法) 定義
一組被定義好的步驟或指令，用於在有限的時間內解決特定問題。
## Criteria
* 輸入(Input): 一個演算法必須有零個或以上輸入量
* 輸出(Output): 一個演算法應有一個或以上輸出量，輸出量是演算法計算的結果。
* 明確性(Definiteness): 一個演算法的每個步驟都必須精確地定義，要執行的動作每一步都必須嚴格地和無歧異地(unambiguous)描述清楚。
* 有限性(Finiteness): 演算法必須在執行有限個步驟後終止。
* 可行性(Effectiveness): 每個指令/敘述必須夠基本，即可在有限時間內被人用紙筆追蹤/執行完成。
## 補充
### 明確性
敘述方式不固定
通常有pseudo code、flow chart兩種。
### Program 與 algorithm 不同點
程序（Program）和演算法（Algorithm）是計算機科學中的兩個基本概念，雖然它們密切相關，但有著不同的功能和特性。

#### **演算法（Algorithm）**

- **定義**：演算法是一組明確的步驟，用於解決特定問題或執行特定任務。它是一種抽象的概念，通常不依賴於特定的編程語言或平台。
- **特性**：
  - **抽象性**：演算法是解決問題的邏輯步驟，獨立於具體的實施方式。
  - **語言中立**：可以用自然語言、流程圖或偽代碼來表達。
  - **不可執行**：演算法本身不能直接執行，需要進一步轉化為程序。

#### **程序（Program）**

- **定義**：程序是演算法的具體實現，使用特定的編程語言編寫，使計算機能夠執行這些指令以達成特定的結果[6][8]。
- **特性**：
  - **具體性**：程序是演算法的具體實施，必須用特定的編程語言來編寫。
  - **語言特定**：程序必須遵循所用編程語言的語法和規則。
  - **可執行性**：程序可以被編譯或解釋後在計算機上執行[1][4]。

#### **比較**

| 特性   | 演算法          | 程序       |
| ---- | ------------ | -------- |
| 定義   | 問題解決的步驟或方法   | 演算法的具體實現 |
| 抽象性  | 抽象且語言中立      | 具體且語言特定  |
| 可執行性 | 不可直接執行       | 可被計算機執行  |
| 表達方式 | 自然語言、偽代碼、流程圖 | 特定編程語言   |

總之，演算法是問題解決的邏輯框架，而程序則是將這些邏輯步驟轉化為計算機可執行的形式。演算法提供了解決問題的方法，而程序則是這些方法的具體實施。

## 參考
https://www.perplexity.ai/search/algorithm-de-ding-yi-shi-shi-m-EGqAK88YRWWgvGp_cw86eQ
https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95
《電腦程式設計藝術》高德納 著
[wjungle大大 筆記](https://www.dropbox.com/s/p9j0wd1hwahum3y/ds.pdf?dl=0)


# Recursion(遞迴)
## 定義(*這個我覺得算是狹義*)
遞迴是Algorithm(或Program)中有自我呼叫(self-calling)敘述的存在。
## 種類
### Direct recursion(直接)
![[Pasted image 20240908211916.png]]
### Indirect recursion(間接)
> 多個modules *(這個叫做module嗎?)* 彼此形成calling cycle
![[Pasted image 20240908211933.png]]
:::danger
實務上禁止
:::
### Tail recursion(尾端)
![[Pasted image 20240908211951.png]]

* Tail recursion 是 Direct recursion的一種
* 在函數結尾時呼叫自己
* 改成非遞迴的方式比較好 *(為什麼?*


## 遞迴與非遞迴

遞迴和非遞迴（迭代）是兩種不同的程式設計方法，各有其特點和適用場景。


| 特點             | 遞迴                               | 非遞迴（迭代）                     |
|------------------|------------------------------------|-----------------------------------|
| 基本思想         | 將問題分解為更小的子問題，使用相同的方法解決 | 使用迴圈逐步計算問題的解           |
| 實現方式         | 通過函數調用自身來實現               | 使用迴圈結構（如 for 或 while）實現 |
| 程式碼複雜度     | 通常較簡潔，但不易理解和除錯         | 可能需要更多程式碼，但通常較直觀   |
| 記憶體使用       | 每次遞迴調用都需要記憶體保存狀態       | 通常使用恆定的記憶體，不需要保存狀態 |
| 效能             | 可能具有較高的記憶體和時間複雜度     | 通常具有較低的記憶體和時間複雜度   |
| 終止條件         | 需要明確定義基本情況以避免無限遞迴   | 控制迭代次數，不需要額外的終止條件 |
| 可讀性           | 把複雜問題單純化，更好理解                       | 遇上複雜問題會不好理解                     |
| 堆棧（Stack）使用 | 使用遞迴堆棧來保存狀態               | 不使用堆棧，通常具有較低的堆棧深度   |
| 優點             | 簡化問題描述，易於理解，適合分解問題 | 效率通常較高，不需要額外的堆棧支持 |
| 缺點             | 可能導致堆棧溢出，效率低下           | 程式碼可能較冗長                   |

遞迴的優勢在於能夠簡化問題的描述，特別是當問題可以自然地分解為相似的子問題時。然而，由於每次遞迴調用都需要保存狀態，遞迴可能導致較高的記憶體使用和較低的效率，特別是在深度遞迴的情況下。

非遞迴（迭代）方法通常更高效，因為它不需要額外的記憶體來保存狀態，並且更適合用於需要大量重複計算的情況。然而，迭代方法的程式碼可能較為冗長，特別是在處理複雜問題時。

在選擇使用遞迴還是迭代時，需考慮問題的性質、程式的可讀性以及效能需求。


## 考型與來源




## 參考
https://www.perplexity.ai/search/di-hui-de-ding-yi-shi-shi-mo-RsDD.CjRSLuyGJ8zJVkW7Q

# 效能分析
## Space

## Time